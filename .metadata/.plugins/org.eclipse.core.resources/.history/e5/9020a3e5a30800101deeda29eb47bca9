package nic.ame.app.esign;

import java.io.ByteArrayOutputStream;
import java.io.File;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.net.URLEncoder;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.charset.StandardCharsets;

import java.text.SimpleDateFormat;
import java.util.Calendar;

import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.session.Session;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

import org.springframework.web.bind.annotation.RequestParam;

import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.pdf.PdfSignatureAppearance;

import jakarta.servlet.ServletContext;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import nic.ame.app.admin.model.RefMedicalExamType;
import nic.ame.app.admin.model.RefRoleMedical;
import nic.ame.app.admin.repository.RefMedicalExamTypeRepo;
import nic.ame.app.admin.repository.RefRoleMedicalRepo;
import nic.ame.app.esign.XMLParse.XMLReadResponseData;

import nic.ame.app.master.dto.ForcePersonnelDto;
import nic.ame.app.master.medical.model.AmeReviewCandidatesList;
import nic.ame.app.master.medical.serviceImpl.eSignAndFinalAMEReportStatusUpdateService;
import nic.ame.app.master.model.AlertAndNotification;
import nic.ame.app.master.model.AmeApprovalProcess;
import nic.ame.app.master.model.AmeApprovalStatus;
import nic.ame.app.master.model.ApplicationStateDescription;
import nic.ame.app.master.model.ForcePersonnel;
import nic.ame.app.master.repository.AlertAndNotificationRepository;
import nic.ame.app.master.repository.AmeApprovalProcessRepository;
import nic.ame.app.master.repository.AmeApprovalStatusRepository;
import nic.ame.app.master.repository.AmeReviewCandidatesListRepository;
import nic.ame.app.master.repository.ApplicationStateDescriptionRepository;
import nic.ame.app.master.repository.ForcePersonnelRepository;
import nic.ame.app.master.service.ForcePersonalService;
import nic.ame.app.master.service.ForcePersonnelService;
import nic.ame.app.master.session.SessionManagement;
import nic.ame.app.sms.SMSConfigurationConstantsAME;
import nic.ame.app.sms.SMSTemplateDto;
import nic.ame.app.sms.SMSTemplateService;
import nic.ame.app.sms.SmsResponse;
import nic.ame.constant.CommonConstant;
import nic.ame.master.util.CreateAlertAndNotification;

@Controller

public class EsignController {

	Logger logger = LoggerFactory.getLogger(EsignController.class);

	@Autowired
	EsignServiceimpl esignClientServiceImp;

	@Autowired
	ServletContext context;

	@Autowired
	private ForcePersonalService forcePersonalService;

	@Autowired
	PdfGenerateForEsign pdfGenerateForEsign;

	@Autowired
	private eSignAndFinalAMEReportStatusUpdateService eSignAndFinalAMEReportStatusUpdateService;

	@Autowired
	private EsignDirCreateService esignDirCreateService;

	@Autowired
	private RefRoleMedicalRepo refRoleMedicalRepo;

	@Autowired
	private ForcePersonnelRepository forcePersonnelRepository;

	@Autowired
	private EsignConfigurationUtil esignConfigurationUtil;

	@Autowired
	private EsignAmeService esignAmeService;
	
	
	@Autowired
	private AmeApprovalStatusRepository ameApprovalStatusRepository;
	
	
	@Autowired
	AmeApprovalProcessRepository ameApprovalProcessRepository;

	@Autowired
	private CreateDuplicateCopyOfOriginalFile createDuplicateCopyOfOriginalFile;

	@GetMapping("esign-pdf")
	public ModelAndView esign(@RequestParam("ameId") String ameId,
			@RequestParam("forcePersonalId") String candidateForcePersonalId, HttpServletRequest request,
			@RequestParam("_csrf") String _csrf, @RequestParam("fileCode") String fileCode,
			@RequestParam(name = "filePath", required = false) String filePath) {

		HttpSession session = request.getSession(false);

		ModelAndView model = new ModelAndView("esign/response");
		String baseUrl = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
				+ request.getContextPath();
		String savePath = null, fileName = null;
		String forcepersonalId = (String) session.getAttribute("forcepersonalId");

		ForcePersonnelDto forcePersonalDetailsForSignee = forcePersonalService.getForcePersonalDetails(forcepersonalId);
		ForcePersonnelDto CandidateforcePersonalDetails = forcePersonalService
				.getForcePersonalDetails(candidateForcePersonalId);

		int rCodeMedical = (int) session.getAttribute("rCodeMedical");

		// process of E-sign for Presiding Officer
		if (rCodeMedical == 2) {

			if (filePath != null)
				savePath = filePath;

			if (createDuplicateCopyOfOriginalFile.fileExists(filePath)) {
				try {
					// save file path for future use

					session.setAttribute("originalFilePath", savePath);
					File file = createDuplicateCopyOfOriginalFile.copyFileToTempFolder(savePath);

					savePath = file.getAbsolutePath();

					fileName = file.getName();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

		}
		// process of E-sign for Approving Authority
		else if (rCodeMedical == 15) {

		} else if (rCodeMedical == 1 || rCodeMedical == 3 || rCodeMedical == 4) {

			// Generate the PDF
			Map<String, Object> outputStreamForGeneratedPdf = pdfGenerateForEsign.generatePdf(ameId,
					candidateForcePersonalId, session, null);
			savePath = esignDirCreateService.createDirectory(fileCode, CandidateforcePersonalDetails,
					forcePersonalDetailsForSignee, outputStreamForGeneratedPdf, ameId);
			fileName = outputStreamForGeneratedPdf.get("fileName").toString().replace(" ", "");
		}

		String esignUrl = esignConfigurationUtil.esginMap.get(StringConstants.url_gatewayUrl);
		MultipartFile userImage = null;

		String st;
		try {
			st = esignClientServiceImp.createHash((String) CandidateforcePersonalDetails.getForceId(), ameId,
					forcePersonalDetailsForSignee.getName(), userImage, session, baseUrl, savePath, fileName);

			// model.addObject("username", forcePersonalDetailsForSignee.getName()+"kskl
			// daskj lkasd lksadlkhlksalk asdlkoyhasdhlas");
			model.addObject("username", forcePersonalDetailsForSignee.getName());
			model.addObject("xml", st);
			model.addObject("acceptClientAction", esignUrl);
			model.addObject("responeUrl", baseUrl + "/final-response");
			logger.info("session Id (2) >>>>>>>>>>>>>>>" + session.getId() + "ctime(2) " + session.getCreationTime());
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return model;
	}

	@PostMapping(value = "final-response")
	@CrossOrigin(originPatterns = { StringConstants.CROSS_ORIGIN_BASE_URL, StringConstants.CROSS_ORIGIN_AME_URL,
			StringConstants.CROSS_ORIGIN_ESIGN_GATEWAY_URL }, allowCredentials = "true", allowedHeaders = "*")
	public String response(@RequestParam(value = "respon", required = false) String respon,
			HttpServletResponse response, HttpServletRequest request, RedirectAttributes redirectAttributes,
			Model model) throws Exception, FileNotFoundException {

		HttpSession session = request.getSession(false);

		String tnxId = null;
		tnxId = XMLReadResponseData.GetTxnId(respon);

		if (tnxId != null) {
			// Optional<EsignRequestData> optional =
			// esignRequestDataRepository.findByTxn(tnxId);

			// Session savedSession =
			// sessionManagement.getSessionById(optional.get().getSessionId());

			if (session != null) {
				String ameId = null, candidateIrlaNuber = null, fileName = null, filePathForSave = null;

				String filePath = null;

				logger.info("response session :" + session.getId());
				File file = (File) session.getAttribute("pdfFile");
				filePath = (String) session.getAttribute("tempfilePath");

				PdfSignatureAppearance appearance = (PdfSignatureAppearance) context.getAttribute(tnxId);
				Map<String, Object> signedMap = esignClientServiceImp.getSignedPdf(respon, appearance);
				boolean status = (boolean) signedMap.get("status");
				logger.info("appearance>>>12 " + appearance);
				fileName = file.getName();

				filePathForSave = file.getAbsolutePath();

				// String encodedFilePath = URLEncoder.encode(filePathForSave,
				// StandardCharsets.UTF_8.toString());

				candidateIrlaNuber = (String) session.getAttribute("candidateIrlaNuber");
				ameId = (String) session.getAttribute("ameId");
				int rCodeMedical = (int) session.getAttribute("rCodeMedical");

				if (status) {

					redirectAttributes.addFlashAttribute("message",
							"AME Final Report eSigned successfully...Ame Report updated...");
					redirectAttributes.addFlashAttribute("fileName", fileName);

					redirectAttributes.addFlashAttribute("filePath", filePathForSave);

					// String encodedPdfUrl = URLEncoder.encode(filePathForSave,
					// StandardCharsets.UTF_8.toString());

					model.addAttribute("pdfUrl", filePathForSave);
					model.addAttribute("message", "AME Final Report eSigned successfully...Ame Report updated...");
					model.addAttribute("msg", "You will be redirected to the main page ..............!");

					Optional<ForcePersonnel> forcePersonnelOptional = forcePersonnelRepository
							.findByForceId(candidateIrlaNuber);
					AmeApprovalProcess ameApprovalProcess = new AmeApprovalProcess();
					String medicalCategory = null;

					if (rCodeMedical == 1) {
						logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> For AMA");
						medicalCategory = eSignAndFinalAMEReportStatusUpdateService.updateAmeFinalResultAfterEsign(
								ameId, forcePersonnelOptional.get().getForcePersonalId(), fileName, filePathForSave);
						esignAmeService.sendAMEResultSMSAndCreateNotificationForCandidate(medicalCategory,
								forcePersonnelOptional, request, ameId);

					}
					if (rCodeMedical == 3 || rCodeMedical == 4) {

						logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> For BM Gazetted Officer ");

						eSignAndFinalAMEReportStatusUpdateService.updateAmeFinalResultAfterEsignBM(ameId,
								medicalCategory, fileName, filePath);

						Long senderRoleCode = 2l;
						Long reciverRole = 10l;
						int statusCode=CommonConstant.BOARD_MEMBER_ESIGN;
						ameApprovalProcess.setAmeId(ameId);
						ameApprovalProcess.setBoardId(null);
						ameApprovalProcess.setCreatedBy(forcePersonnelOptional.get().getForcePersonalId());
						Optional<RefRoleMedical> senderRole = refRoleMedicalRepo.findById(senderRoleCode);
						ameApprovalProcess.setSenderRoleCode(senderRole.get());
						Optional<RefRoleMedical> reciverRoleMedical = refRoleMedicalRepo.findById(reciverRole);
						ameApprovalProcess.setReceiverRoleCode(reciverRoleMedical.get());
						ameApprovalProcess.setCreatedOn(Calendar.getInstance().getTime());
						ameApprovalProcess.setActiveStatus(true);
						AmeApprovalStatus ameApprovalStatus;
						Optional<AmeApprovalStatus> optional = ameApprovalStatusRepository.findById(statusCode);
						if (optional.isPresent()) {
						     ameApprovalStatus = optional.get();  // Managed entity
						    ameApprovalProcess.setAmeApprovalStatus(ameApprovalStatus);
						    ameApprovalProcessRepository.save(ameApprovalProcess);
						} else {
						    System.out.println("AmeApprovalStatus with the given statusCode does not exist.");
						}

					}
					if (rCodeMedical == 2) {
						logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> For PO Gazetted Officer ");
						String originalFilePath = (String) session.getAttribute("originalFilePath");

						eSignAndFinalAMEReportStatusUpdateService.updateAmeFinalResultAfterEsignPO(ameId,
								medicalCategory, fileName, filePath, originalFilePath);
						// save
					}
					if (rCodeMedical == 15) {
						logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> For AA Gazetted Officer ");
						eSignAndFinalAMEReportStatusUpdateService.updateAmeFinalResultAfterEsignAA(ameId,
								medicalCategory, fileName, filePath);
						esignAmeService.sendAMEResultSMSAndCreateNotificationForCandidate(medicalCategory,
								forcePersonnelOptional, request, ameId);

					}

					// eSignAndFinalAMEReportStatusUpdateService.getIndividualFinalAMECategory(ameId,
					// candidateForcePersonnelId);
				}
				context.removeAttribute(tnxId);
			}

			return "medical-sub-ordinate/NGO/view-signed-pdf";

		} else {
			logger.info("Session is null and we are redireting to login page....!");
			model.addAttribute("message", "AME Final Report eSigned ERROR ERROR ERROR..........Ame Report updated...");
			model.addAttribute("msg", "You will be redirected to the main page ..............!");
			return "medical-sub-ordinate/NGO/view-signed-pdf-error";
		}

	}

	@PostMapping("esign-response-close")
	String redirectedPdfSigned(HttpServletRequest httpServletRequest, RedirectAttributes redirectAttributes,
			@RequestParam("respon") String responseEsign, Model model) throws Exception {

		HttpSession httpSession = httpServletRequest.getSession(false);

		String ameId = null, candidateForcePersonnelId = null, fileName = null, filePathForSave = null;
		// logger.info("session Id (3) >>>>>>>>>>>>>>>" + session.getId() + ">>> " +
		// session.getCreationTime());

		logger.info("Recived Response>>> next method " + responseEsign);
		String filePath = null;

		// PdfSignatureAppearance appearance = (PdfSignatureAppearance)
		// context.getAttribute("appearancepdf");
		// session=(HttpSession)context.getAttribute("session");

		File file = (File) httpSession.getAttribute("pdfFile");
		filePath = (String) httpSession.getAttribute("tempfilePath");

		// logger.info("security context:...."+context.getAttribute("authentication"));
		// logger.info("contextSecurityContext:...."+context.getAttribute("contextSecurityContext"));
		System.out.println("file " + file);

		PdfSignatureAppearance appearance = (PdfSignatureAppearance) httpSession.getAttribute("appearancepdf");

		logger.info("appearance>>> " + appearance);
		redirectAttributes.addFlashAttribute("session", httpSession);

		logger.info("file " + file.getAbsolutePath());
		// logger.info("setting session......and sending it....");
		fileName = file.getName();

		filePathForSave = file.getAbsolutePath();

		String encodedFilePath = URLEncoder.encode(filePathForSave, StandardCharsets.UTF_8.toString());

		candidateForcePersonnelId = (String) httpSession.getAttribute("candidateForcePersonnnelId");
		ameId = (String) httpSession.getAttribute("ameId");

		Map<String, Object> signedMap = esignClientServiceImp.getSignedPdf(responseEsign, appearance);
		String msg = (String) signedMap.get("errorMessage");
		String errcode = (String) signedMap.get("errcode");
		String exMessage = (String) signedMap.get("exMessage");
		boolean status = (boolean) signedMap.get("status");
		if (status) {

			redirectAttributes.addFlashAttribute("message",
					"AME Final Report eSigned successfully...Ame Report updated...");
			redirectAttributes.addFlashAttribute("fileName", fileName);

			redirectAttributes.addFlashAttribute("filePath", filePathForSave);
			SMSTemplateDto smsTemplateDto = new SMSTemplateDto();

			/*
			 * String MedicalCategory=eSignAndFinalAMEReportStatusUpdateService.
			 * updateAmeFinalResultAfterEsign(ameId, candidateForcePersonnelId, fileName,
			 * filePathForSave); SimpleDateFormat simpleDateFormat=new
			 * SimpleDateFormat("dd-MM-YYYY");
			 * smsTemplateDto.setAmeCompletedOnDate(simpleDateFormat.format(Calendar.
			 * getInstance().getTime()));
			 * smsTemplateDto.setCategoryAwarded(MedicalCategory);
			 * Optional<ForcePersonnelDto> forcePersonnelOptional
			 * =forcePersonalService.findByForcePersonalId(candidateForcePersonnelId);
			 * smsTemplateDto.setIrlaNo(forcePersonnelOptional.get().getForceId());
			 * smsTemplateService.ameSMS(smsTemplateDto,
			 * SMSConfigurationConstantsAME.DLT_TEMPLATE_ID_AME_SMS);
			 * logger.info("Final report status updated...........!"+filePathForSave);
			 */
			model.addAttribute("message", "AME Final Report eSigned successfully...Ame Report updated...");
			model.addAttribute("msg", "You will be redirected to the main page ..............!");
			// String encodedPdfUrl = URLEncoder.encode(filePathForSave,
			// StandardCharsets.UTF_8.toString());
			model.addAttribute("pdfUrl", filePathForSave);
			logger.info("esign success......" + filePathForSave);
		} else {
			model.addAttribute("message", "AME Final Report eSigned unsuccessful...Please try again...after some time");
			model.addAttribute("msg", "You will be redirected to the main page ..............!");
			// model.addAttribute("pdfUrl", filePathForSave);
			logger.info("esign unsuccess......" + filePathForSave);

		}

		/*            
		 * Desktop desktop = Desktop.getDesktop(); File file = new File(filePath); //
		 * Local Test on Window OS if(file.exists()) desktop.open(file);
		 */

		/*
		 * File pdfFile = new File(filePathForSave); // Using File instead of Path
		 * 
		 * // Check if file exists if (!pdfFile.exists()) { try {
		 * response.setStatus(HttpServletResponse.SC_NOT_FOUND);
		 * response.getWriter().write("File not found"); } catch (IOException e) {
		 * e.printStackTrace(); } }
		 * 
		 * // Set response headers response.setContentType("application/pdf");
		 * response.setHeader("Content-Disposition", "inline; filename=\"" +
		 * pdfFile.getName() + "\"");
		 * 
		 * // Stream the file content try (FileInputStream fis = new
		 * FileInputStream(pdfFile); ServletOutputStream outputStream =
		 * response.getOutputStream()) {
		 * 
		 * byte[] buffer = new byte[1024]; int bytesRead;
		 * 
		 * // Read and write the file content in chunks to avoid memory issues with
		 * large files while ((bytesRead = fis.read(buffer)) != -1) {
		 * outputStream.write(buffer, 0, bytesRead); } outputStream.flush();
		 * 
		 * } catch (IOException e) { // Handle exceptions
		 * response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); try {
		 * response.getWriter().write("Error reading or sending the file: " +
		 * e.getMessage()); } catch (IOException ioException) {
		 * ioException.printStackTrace(); } e.printStackTrace(); }
		 */
		return "medical-sub-ordinate/NGO/view-signed-pdf";

	}

	@GetMapping("generateamefinalPdf")
	public String generateamefinalPdfNow(@RequestParam String forcepersonalId, @RequestParam String ameId,
			Model model) {
		logger.info("/generateamefinalPdf");
		model.addAttribute("forcepersonalId", forcepersonalId);
		model.addAttribute("ameId", ameId);
		return "UserMenu/view-ame-final-esign-pdf"; // Return the view name
	}

	@GetMapping("viewAmeFinalPdf")
	public void generateamefinalPdfView(@RequestParam("ameId") String ameId,
			@RequestParam("forcepersonalId") String forcepersonalId, HttpSession session, HttpServletResponse response,
			HttpServletRequest httpServletRequest) {
		try {
			// Generate the PDF
			Map<String, Object> pdfResponse = pdfGenerateForEsign.generatePdf(ameId, forcepersonalId, session, null);
			System.out.println("Generated PDF size: " + (pdfResponse != null ? pdfResponse.size() : "null"));

			// Prepare the response
			ByteArrayOutputStream outputStream = (ByteArrayOutputStream) pdfResponse.get("fileOutputStreamObject");
			byte[] pdfBytes = outputStream.toByteArray();

			// Set response headers
			response.setContentType("application/pdf");
			response.setHeader("Content-Disposition", "inline; filename=generated.pdf");
			response.setContentLength(pdfBytes.length);
			response.getOutputStream().write(pdfBytes);
			response.getOutputStream().flush();

		} catch (Exception e) {
			e.printStackTrace();
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
	}

}